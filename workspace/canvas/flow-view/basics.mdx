---
title: "Flow View Basics"
description: "Understanding the fundamentals of Flow visualization"
---

## What is Flow View?

Flow View is the detailed canvas that appears when you double-click a Flow node. It shows the internal structure of the Flow: all nodes, connections (edges), and data flow paths.

## Why Flow View matters

- **Visualize logic** — See exactly how data moves through your system
- **Debug easily** — Identify where failures occur
- **Understand complexity** — Grasp multi-step workflows at a glance
- **Edit confidently** — Modify structure without breaking connections

## Anatomy of Flow View

### The Canvas

The main area where nodes and edges appear.

- **Grid background** — Helps align nodes
- **Infinite canvas** — Pan and zoom freely
- **Selection box** — Drag to select multiple nodes

### Node types

**Input Node (green)**
- Entry point for data into the Flow
- Defines expected input schema
- Usually one per Flow (can have multiple for complex scenarios)

**Processing Nodes (blue/purple)**
- Actions: Deterministic Python functions
- Agents: LLM-powered decision-makers
- Sub-Flows: Nested workflows

**Output Node (orange)**
- Exit point for data from the Flow
- Defines output schema
- Can have multiple for different outcomes (success, error, etc.)

**Control Nodes (gray)**
- Router: Conditional branching
- Merge: Combine multiple paths
- Loop: Iterate over items

### Edge types

**Data edges (blue)**
- Solid lines connecting nodes
- Show data flow direction
- Labeled with field names when hovering

**Control edges (orange)**
- Show conditional or loop logic
- Labeled with conditions (e.g., "if status == 'urgent'")

**Inactive edges (gray)**
- Not used in recent executions
- May indicate dead code

## Reading a Flow

### Following the path

Flows generally read **left to right**:

```
Input → Process → Transform → Output
```

### Branching logic

When edges split, it means conditional routing:

```
Input → Check → [if valid] → Process → Output
              → [if invalid] → Error Handler → Output
```

### Parallel operations

When multiple nodes are side-by-side at the same level:

```
Input → Fetch A ↘
            Fetch B → Combine → Output
        Fetch C ↗
```

This means Fetch A, B, and C run simultaneously.

### Sequential operations

When nodes are in a straight line:

```
Input → Step 1 → Step 2 → Step 3 → Output
```

Each step waits for the previous one to complete.

## Interacting with Flow View

### Basic navigation

**Pan:** Click and drag empty space  
**Zoom:** Mouse wheel or trackpad pinch  
**Fit:** Press `F` to see the entire Flow  
**Reset:** Press `R` to reset zoom and position

### Selecting nodes

**Single select:** Click a node  
**Multi-select:** Hold `Shift` and click multiple nodes  
**Box select:** Click and drag to create selection box  
**Select all:** `Cmd+A` (Mac) / `Ctrl+A` (Windows)

### Viewing node details

**Click** a node to see its properties in the Properties Panel:
- Input/output schema
- Configuration
- Execution history
- Logs and errors

**Double-click** a node to drill deeper:
- For Flows: Opens the Flow's internal structure
- For Agents: Shows configuration (in Properties Panel)
- For Actions: Shows code (in Properties Panel)

### Inspecting edges

**Hover** over an edge to see:
- Source node and output port
- Destination node and input port
- Data type being passed
- Field mapping (if any)

**Click** an edge to select it (for deletion or modification).

## Understanding execution visualization

When you select a past execution from Properties → Executions, the Canvas shows what happened:

### Node states

**Green** — Executed successfully  
**Red** — Failed with error  
**Yellow** — Currently executing (live view)  
**Gray** — Skipped (not part of this execution path)

### Edge highlighting

**Bold blue** — Data flowed through this connection  
**Faded gray** — Not used in this execution

### Timing information

Hover over nodes to see:
- Execution start time
- Execution duration
- Wait time (if queued)

## Common Flow patterns

### Pattern 1: Linear pipeline

```
Input → Validate → Process → Format → Output
```

**Use case:** Simple, sequential data processing  
**Benefits:** Easy to understand, predictable  
**Limitations:** Can be slow for large datasets

### Pattern 2: Fan-out / Fan-in

```
Input → Split → Process A ↘
                 Process B → Merge → Output
             Process C ↗
```

**Use case:** Parallel processing of independent tasks  
**Benefits:** Faster, utilizes concurrency  
**Limitations:** Requires merge logic

### Pattern 3: Conditional routing

```
Input → Router → [urgent] → Fast Track → Output
              → [normal] → Standard → Output
              → [low] → Batch → Output
```

**Use case:** Different handling based on conditions  
**Benefits:** Optimized for each scenario  
**Limitations:** More complex to maintain

### Pattern 4: Error handling

```
Input → Process → [success] → Output
              → [error] → Log → Retry → Output (or Dead Letter Queue)
```

**Use case:** Robust systems that handle failures gracefully  
**Benefits:** Reliability, observability  
**Limitations:** Additional nodes and complexity

## Flow complexity indicators

### Simple Flow
- 3-7 nodes
- Linear or single branch
- Easy to understand at a glance

### Moderate Flow
- 8-15 nodes
- Multiple branches or parallel paths
- Some conditional logic

### Complex Flow
- 16+ nodes
- Nested conditions
- Multiple parallel paths
- Consider splitting into sub-Flows

## Best practices

> **Keep it visual** — Arrange nodes clearly, use space wisely

> **Name nodes descriptively** — "Validate Email" beats "Action_1"

> **Use sub-Flows** — Break complex logic into manageable pieces

> **Test incrementally** — Verify each section works before adding more

> **Document non-obvious logic** — Add comments for future you

## Next steps

Continue exploring the Flow View documentation to learn about creating and connecting nodes, understanding I/O nodes, and node interactions.
